# 1.0

早先`1.0`的`HTTP`版本，是一种**无状态、无连接**的应用层协议。

**无状态**：服务器不跟踪每个客户端也不记录过去的请求，无状态性可以借助`cookie/session`机制来做身份认证和状态记录。

**无连接**：浏览器的每次请求都需要与服务器建立一个`TCP`连接，服务器处理完成后立即断开`TCP`连接，无连接的特性导致最大的性能缺陷就是**无法复用连接**；

**队头阻塞**：由于`HTTP1.0`规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。

# 1.1

**长连接**：`HTTP1.1`增加了一个`Connection`字段，通过设置`Keep-Alive`可以保持`HTTP`连接不断开；如果客户端想关闭`HTTP`连接，可以在请求头中携带`Connection: false`来告知服务器关闭请求。

**管道化**：**服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。**不允许同时存在两个**并行的响应**。，`HTTP1.1`还是无法解决队头阻塞（`head of line blocking`）

HTTP Pipelining其实是把**多个HTTP请求放到一个TCP连接中一一发送**，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。

并发多个请求需要多个TCP连接，浏览器为了控制资源会有**6-8个TCP连接**都限制。

此外，`HTTP1.1`还加入了**缓存处理（强缓存和协商缓存[[传送门](http://www.yangzicong.com/article/12)]）**新的字段如`cache-control`，支持**断点传输**，以及增加了**Host字段**（使得一个服务器能够用来创建多个Web站点）。



1.1只是解决了每次请求都要建立一次连接的问题，但是并没有解决队头阻塞的问题

# 2.0

**二进制分帧**：在应用层(HTTP2.0)和传输层(TCP or UDP)之间增加一个二进制分帧层。在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。

**多路复用（连接共享）**：`HTTP2.0`实现了真正的并行传输，它能够在一个`TCP`上进行任意数量`HTTP`请求。而这个强大的功能则是基于“二进制分帧”的特性。一个TCP连接可以进行乱序传输

**头部压缩**：`HTTP2.0`使用`encoder`来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，

**服务器推送**：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。



在 **HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手**，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题：

- 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）
- 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。

HTTP/2的多路复用就是为了解决上述的两个性能问题。
在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。
帧代表着最小的数据单位，**每个帧会标识出该帧属于哪个流**，流也就是多个帧组成的数据流。
多路复用，**就是在一个 TCP 连接中可以存在多条流**。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。





# 3.0 QUIC

上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。

因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据

QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。