# 1.0

早先`1.0`的`HTTP`版本，是一种**无状态、无连接**的应用层协议。

**无状态**：服务器不跟踪每个客户端也不记录过去的请求，无状态性可以借助`cookie/session`机制来做身份认证和状态记录。

**无连接**：浏览器的每次请求都需要与服务器建立一个`TCP`连接，服务器处理完成后立即断开`TCP`连接，无连接的特性导致最大的性能缺陷就是**无法复用连接**；

**队头阻塞**：由于`HTTP1.0`规定下一个请求必须在前一个请求响应到达之前才能发送。假设前一个请求响应一直不到达，那么下一个请求就不发送，同样的后面的请求也给阻塞了。

# 1.1

**长连接**：`HTTP1.1`增加了一个`Connection`字段，通过设置`Keep-Alive`可以保持`HTTP`连接不断开；如果客户端想关闭`HTTP`连接，可以在请求头中携带`Connection: false`来告知服务器关闭请求。

**管道化**：**服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。**不允许同时存在两个**并行的响应**。，`HTTP1.1`还是无法解决队头阻塞（`head of line blocking`）

HTTP Pipelining其实是把**多个HTTP请求放到一个TCP连接中一一发送**，而在发送过程中不需要等待服务器对前一个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应。

此外，`HTTP1.1`还加入了**缓存处理（强缓存和协商缓存[[传送门](http://www.yangzicong.com/article/12)]）**新的字段如`cache-control`，支持**断点传输**，以及增加了**Host字段**（使得一个服务器能够用来创建多个Web站点）。



1.1只是解决了每次请求都要建立一次连接的问题，但是并没有解决队头阻塞的问题

# 2.0

**二进制分帧**：在应用层(HTTP2.0)和传输层(TCP or UDP)之间增加一个二进制分帧层。在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码 ，其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。

**多路复用（连接共享）**：`HTTP2.0`实现了真正的并行传输，它能够在一个`TCP`上进行任意数量`HTTP`请求。而这个强大的功能则是基于“二进制分帧”的特性。一个TCP连接可以进行乱序传输

**头部压缩**：`HTTP2.0`使用`encoder`来减少需要传输的`header`大小，通讯双方各自`cache`一份`header fields`表，既避免了重复`header`的传输，

**服务器推送**：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。



# 3.0 QUIC

上文提到 HTTP/2 使用了多路复用，一般来说同一域名下只需要使用一个 TCP 连接。但当这个连接中出现了丢包的情况，那就会导致 HTTP/2 的表现情况反倒不如 HTTP/1 了。

因为在出现丢包的情况下，整个 TCP 都要开始等待重传，也就导致了后面的所有数据都被阻塞了。但是对于 HTTP/1.1 来说，可以开启多个 TCP 连接，出现这种情况反到只会影响其中一个连接，剩余的 TCP 连接还可以正常传输数据

QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。