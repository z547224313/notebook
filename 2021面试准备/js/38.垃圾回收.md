# 原理

 JavaScript 内存管理中有一个概念叫做 `可达性`

js的垃圾回收就是寻找不可达的对象，予以清理



# 标记清除法

最常用

整个标记清除算法大致过程就像下面这样

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

### 优点

操作简单只有两种标记

### 缺点

在清除垃圾之后，剩余对象的内存位置是不变的，导致不连续 **内存碎片化** **分配速度慢**

 **标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）**向内存的一端移动**，最后清理掉边界的内存（如下图）

# 引用计数法

最古老

当没有其他变量对该对象引用时，**立即**进行垃圾回收

它的策略是跟踪记录每个变量值被使用的次数

- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
- 如果同一个值又被赋给另一个变量，那么引用数加 1
- 如果该变量的值被其他的值覆盖了，则引用次数减 1
- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存



### 优点

引用计数在引用值为 0 时，可以立即垃圾回收

标记计数法需要每隔一段时间浏览器开启一个新的线程去进行垃圾回收

### 缺点

需要一个占用位置很大的计数器





# v8中的优化

标记清除算法

### 分代式垃圾回收（减少了每次标记的次数）

- 老生代区域：直接进行标记清除（占用空间大，存活时间长的）

- 新生代：

  - 使用区：新对象加入，满后进行标记复制进空闲区，互换双方位置

  - 空闲区：多次被复制的对象加入老生代区域

  - https://juejin.cn/post/6981588276356317214#heading-7

    

