# 为什么需要hook

## class组件的优势

- class可以定义自己的state,用来保存自己的状态。函数组件每次调用都会产生新的临时变量
- class有生命周期
- class可以在状态改变时只重新执行render以及生命周期componentDidUpdate而函数组件整个函数都会重新执行

## class组件的问题

- 组件难以理解

  比如在componentDidMount中会包含大量逻辑代码，网络请求和一些事件监听，还需要在unMount事件中移除

- 太过整合无法拆分，逻辑混杂

- this指向麻烦 
- 状态共享方式复杂，如context.provider

# useState

## 初体验

useState

本身是一个函数

参数: 给创建出来的状态一个默认值

返回值: 是一个数组，

0下标：当前state的值，

1下标：设置新的值时，使用的一个函数

注意这个函数可以传要更改的值，或者传一个函数返回值的要更改的值，函数的参数时之前的值

```js
setState(count)

setState((preCount)=>{
    return preCount +10
})
//这两个的区别是第一个放入函数中多次调用时会被合并只有一个生效，因为拿不到之前的sate
//函数的会直接拿到之前的值，甚至是上一个函数改变后的。
```



`原则`

- 只能在函数最外层使用hook
- 只能在react函数组件中调用hook

```react
import React ,{useState}from 'react';

function App(props) {
  const arr = useState(0)
  const state = arr[0]
  const setState = arr[1]

  return (
      <div>
        counter：{state}
        <button onClick={event => setState(state+1)}>+1</button>
        <button onClick={event => setState(state-1)}>-1</button>
      </div>

  );
}

export default App;
```

## 多个状态

```react
import React ,{useState}from 'react';

function MultiData(props) {
  const [age,setAge] = useState(18)
  const [name,setName] = useState('zhangpeng')
  const [friends,setFriends] = useState(['lilei','hanmeimei'])
  const [students,setStudents] = useState([
    {age:18,name:'kobe',id:111},
    {age:19,name:'kobccce',id:112},
    {age:133,name:'sdfgobe',id:113},
  ])

  function addStudentAge(index){
    const newStudent = [...students]
    newStudent[index].age+=1
    setStudents(newStudent)
  }

  return (
      <div>
        <h2>age:{age}</h2>
        <h2>name:{name}</h2>
        <div>friend:{friends.map(item =>{
          return (
              <div>{item}</div>
          )
        })
        }</div>
        <button onClick={event => setFriends([...friends,'tomato'])}>添加朋友</button>

        <div>
          {students.map((item,index) =>{
            return (
                <div>
                  <span>age:{item.age}</span>
                  <span>name:{item.name}</span>
                  <span>id:{item.id}</span>
                  <button onClick={event => addStudentAge(index)}>age+1</button>
                </div>
            )
          })}
        </div>
      </div>
  );
}

export default MultiData;

```

# useEffect

完成类似class组件生命周期的功能

第一个参数：回调函数

第二个参数： 数组，传入依赖，只有当被依赖的内容发生改变时才会重新被调用，传入空数组就只会在didMount时调用一次

默认情况下合并了didMount和DidUpdate

第一次挂载和每次更新都会执行

返回值是一个函数代表了unMount

## 模拟订阅取消操作

```js
import React,{useEffect,useState} from 'react';

function Effect(props) {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    //这里默认情况是didMount,didUpdate
    console.log('订阅事件')

    return ()=>{
      //默认unMount
      console.log('取消订阅')
    }
  },[])

  return (
      <div>
        <h2>count:{count}</h2>
        <button onClick={event => setCount(count+1)}>+1</button>
      </div>
  );
}

export default Effect;

```

## dep参数详解，多个调用

多个effect按顺序调用

dep参数依赖改变时才会重新执行，否则只在didMount中执行一次

```react
import React,{useEffect,useState} from 'react';

function Effect(props) {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    //只有count修改时才会被调用
    console.log('修改dom', count)
  },[count])

  useEffect(()=>{
    console.log('订阅事件')
    return ()=>{
      //默认unMount
      console.log('取消订阅')
    }
  },[])

  useEffect(()=>{
    console.log('网络请求')
  },[])
  return (
      <div>
        <h2>count:{count}</h2>
        <button onClick={event => setCount(count+1)}>+1</button>
      </div>
  );
}

export default Effect;

```



# useContext

创建还是使用createContext

创建

```react
export const UserContext = createContext();
export const AgeContext = createContext() 

<UserContext.Provider value={{user:'1111'}}>
   <AgeContext.Provider value={{age:18}}>
      <Context/>
   </AgeContext.Provider>
</UserContext.Provider>
```

使用

```react
import React,{useContext} from 'react';
import {UserContext,AgeContext} from "./App";

function Context(props) {
  const user = useContext(UserContext)
  const age = useContext(AgeContext)

  console.log(user,age)
  return (
      <div>111</div>
  );
}

export default Context;

```

# useReducer

当state的处理逻辑比较复杂时，使用useReducer对useState进行替代

```js
import React,{useReducer} from 'react';


function reducer(state,action){
  switch (action.type){
    case 'add':
      return {...state,counter:state.counter+1};
    default:
      return state
  }
}

function UseReducer(props) {

  const [state, dispatch] = useReducer(reducer,{counter:0})

  return (
      <div>
        <h2>counter:{state.counter}</h2>
        <button onClick={event => dispatch({type:'add'})}>+1</button>
      </div>
  );
}

export default UseReducer;

```

# useCallback

目的是进行性能优化。

