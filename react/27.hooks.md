# 为什么需要hook

## class组件的优势

- class可以定义自己的state,用来保存自己的状态。函数组件每次调用都会产生新的临时变量
- class有生命周期
- class可以在状态改变时只重新执行render以及生命周期componentDidUpdate而函数组件整个函数都会重新执行

## class组件的问题

- 组件难以理解

  比如在componentDidMount中会包含大量逻辑代码，网络请求和一些事件监听，还需要在unMount事件中移除

- 太过整合无法拆分，逻辑混杂

- this指向麻烦 

- 状态共享方式复杂，如context.provider

# useState

## 初体验

useState

本身是一个函数

参数: 给创建出来的状态一个默认值

返回值: 是一个数组，

0下标：当前state的值，

1下标：设置新的值时，使用的一个函数

注意这个函数可以传要更改的值，或者传一个函数返回值的要更改的值，函数的参数时之前的值

```js
setState(count)

setState((preCount)=>{
    return preCount +10
})
//这两个的区别是第一个放入函数中多次调用时会被合并只有一个生效，因为拿不到之前的sate
//函数的会直接拿到之前的值，甚至是上一个函数改变后的。
```



`原则`

- 只能在函数最外层使用hook
- 只能在react函数组件中调用hook

```react
import React ,{useState}from 'react';

function App(props) {
  const arr = useState(0)
  const state = arr[0]
  const setState = arr[1]

  return (
      <div>
        counter：{state}
        <button onClick={event => setState(state+1)}>+1</button>
        <button onClick={event => setState(state-1)}>-1</button>
      </div>

  );
}

export default App;
```

## 多个状态

```react
import React ,{useState}from 'react';

function MultiData(props) {
  const [age,setAge] = useState(18)
  const [name,setName] = useState('zhangpeng')
  const [friends,setFriends] = useState(['lilei','hanmeimei'])
  const [students,setStudents] = useState([
    {age:18,name:'kobe',id:111},
    {age:19,name:'kobccce',id:112},
    {age:133,name:'sdfgobe',id:113},
  ])

  function addStudentAge(index){
    const newStudent = [...students]
    newStudent[index].age+=1
    setStudents(newStudent)
  }

  return (
      <div>
        <h2>age:{age}</h2>
        <h2>name:{name}</h2>
        <div>friend:{friends.map(item =>{
          return (
              <div>{item}</div>
          )
        })
        }</div>
        <button onClick={event => setFriends([...friends,'tomato'])}>添加朋友</button>

        <div>
          {students.map((item,index) =>{
            return (
                <div>
                  <span>age:{item.age}</span>
                  <span>name:{item.name}</span>
                  <span>id:{item.id}</span>
                  <button onClick={event => addStudentAge(index)}>age+1</button>
                </div>
            )
          })}
        </div>
      </div>
  );
}

export default MultiData;

```

# useEffect

完成类似class组件生命周期的功能

第一个参数：回调函数

第二个参数： 数组，传入依赖，只有当被依赖的内容发生改变时才会重新被调用，传入空数组就只会在didMount时调用一次

默认情况下合并了didMount和DidUpdate

第一次挂载和每次更新都会执行

返回值是一个函数代表了unMount

## 模拟订阅取消操作

```js
import React,{useEffect,useState} from 'react';

function Effect(props) {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    //这里默认情况是didMount,didUpdate
    console.log('订阅事件')

    return ()=>{
      //默认unMount
      console.log('取消订阅')
    }
  },[])

  return (
      <div>
        <h2>count:{count}</h2>
        <button onClick={event => setCount(count+1)}>+1</button>
      </div>
  );
}

export default Effect;

```

## dep参数详解，多个调用

多个effect按顺序调用

dep参数依赖改变时才会重新执行，否则只在didMount中执行一次

```react
import React,{useEffect,useState} from 'react';

function Effect(props) {
  const [count, setCount] = useState(0)

  useEffect(()=>{
    //只有count修改时才会被调用
    console.log('修改dom', count)
  },[count])

  useEffect(()=>{
    console.log('订阅事件')
    return ()=>{
      //默认unMount
      console.log('取消订阅')
    }
  },[])

  useEffect(()=>{
    console.log('网络请求')
  },[])
  return (
      <div>
        <h2>count:{count}</h2>
        <button onClick={event => setCount(count+1)}>+1</button>
      </div>
  );
}

export default Effect;

```



# useContext

创建还是使用createContext

创建

```react
export const UserContext = createContext();
export const AgeContext = createContext() 

<UserContext.Provider value={{user:'1111'}}>
   <AgeContext.Provider value={{age:18}}>
      <Context/>
   </AgeContext.Provider>
</UserContext.Provider>
```

使用

```react
import React,{useContext} from 'react';
import {UserContext,AgeContext} from "./App";

function Context(props) {
  const user = useContext(UserContext)
  const age = useContext(AgeContext)

  console.log(user,age)
  return (
      <div>111</div>
  );
}

export default Context;

```

# useReducer

当state的处理逻辑比较复杂时，使用useReducer对useState进行替代

```js
import React,{useReducer} from 'react';


function reducer(state,action){
  switch (action.type){
    case 'add':
      return {...state,counter:state.counter+1};
    default:
      return state
  }
}

function UseReducer(props) {

  const [state, dispatch] = useReducer(reducer,{counter:0})

  return (
      <div>
        <h2>counter:{state.counter}</h2>
        <button onClick={event => dispatch({type:'add'})}>+1</button>
      </div>
  );
}

export default UseReducer;

```

# useCallback

目的是进行性能优化。

主要用在将一个组件中的函数传递给子元素进行回调使用时，使用useCallback对函数进行处理

一般跟memo函数组件共同使用

参数1：回调函数

参数2：依赖数组

返回值：回调函数的记忆版本memoized

只有当依赖数组发生改变时，回调函数才会重新执行

demo

```react
import React,{useState,useCallback,memo} from 'react';

const HyBtn = memo((props)=>{
  console.log(props.title,'重新渲染')
  return (
      <button onClick={props.add}>+1</button>
  )})

function Callback(props) {
  const [counter,setCounter] = useState(0)
  const [show,setShow] = useState(false)

  const add1 = ()=>{
    console.log('add1')
    setCounter(counter+1)
  }

  const add2 = useCallback(()=>{
    console.log('add2')
    setCounter(counter+1)
  },[counter])

  return (
      <div>
        <h2>counter:{counter}</h2>
        <HyBtn title='add1' add={add1}/>
        <HyBtn title='add2' add={add2}/>
        <h2>{show}</h2>
        <button onClick={event => setShow(!show)}>changeShow</button>
      </div>
  ;
}

export default Callback;

```

注意memo会对props进行浅层比较，如果props浅层无变化，则该函数组件不会重新执行

如上实例当show发生改变时，整个大组件重新执行 render 

这时 add 1和add2都进行了重新赋值，只不过使用useCallback的add2依赖无变化，导致返回的回调函数还是上一个，所以子组件浅层比较memo时候props无变化，所以子组件不会重新执行，优化了函数.

#  useMemo

useCallback 传入一个回调函数，最后返回值也是一个函数

useMemo 传入一个函数，这个函数的返回值将作为useMemo的返回值，useMemo可以返回对象，也可以返回一个函数，返回函数的时候就是useCallback



```js
useCallback(()=>{
    console.log('1111')
},[])

useMemo(()=>{
    return ()=>{
        console.log('1111')
    }
},[])
//以上两方法一样
```



返回值是一个数字的情况

```react
import React,{useMemo,useState} from 'react';

  function calc(counter){
    console.log('重新计算')
    let res = 0
    for(let i = 0;i<counter;i++){
      res += i
    }
    return res
  }

function UseMemoCal(props) {
  const [counter,setCounter] = useState(1)
  const [show,setShow] = useState(false)

  let calcMemoRes = useMemo(()=>{
    //当counter 不改变的时候，这个useMemo就会返回之前的返回值，不会重新调用calc来计算
    //这里的返回值是一个数
    return calc(counter)
  },[counter])

  return (
      <div>
        <h2>综合:{calcMemoRes}</h2>
        <button onClick={event => setCounter(counter+1)}>+1</button>
        <button onClick={event => setShow(!show)}>changeShow</button>
      </div>
  );
}

export default UseMemoCal;

```



返回值是对象时，因为重新执行函数式组件时，对于相同内容的对象，也会赋予不同的地址值，所以对于传入另外一个子组件的props是改变的，子组件也要重新渲染，这时内容其实并没有发生变化，

这时使用useMemo返回这个对象，再传入子组件中，对于固定内容的对象是不会导致子组件重新渲染的



